# Generative Storytelling with Snap!: A 12-Lesson Curriculum

## [Lesson 1: The Journey Begins – Introduction to Generative Storytelling](https://chatgpt.com/c/67adc8a9-110c-8002-8e3b-eb41dc2d4a19)

### Introduction

Imagine a story that changes every time you read it – forests that shift, heroes with different fates, twists that even the author didn't predict. Welcome to generative storytelling, where we **build worlds with code**. In this first lesson, you will embark on a creative adventure using Snap!, a beginner-friendly visual programming language, to craft stories that write themselves. We’ll set the stage for your very own dynamic story universe, one that combines the age-old joy of world-building with the power of computational thinking. Digital storytelling has emerged as an innovative way to engage learners in deep, meaningful learning experiences ([Smith-CameraReadyv4](https://intellimedia.ncsu.edu/wp-content/uploads/sites/42/smith-icids-2020.pdf#:~:text=Digital%20storytelling%2C%20which%20combines%20traditional,and%20creative%20exploration%20of)), and now you get to experience why. By writing simple programs, you'll breathe life into an imaginary world – one that evolves with each run of your code. So, ready your imagination and let’s begin our journey into generative storytelling!

### Key Concepts

- **Generative Storytelling**: The art of using algorithms and code to create content (in our case, story narratives) that can change or evolve on its own. Instead of a fixed tale, a generative story is unpredictable and new on each run. This approach makes your storytelling **dynamic**, as if the story itself is alive and creative. It also highlights the joy of **world-building**, which is the process of constructing an imaginary world with its own rules and details ([National Novel Writing Month — Worlds Within Words: A Structural World-Building Exercise](https://blog.nanowrimo.org/post/158974901276/worlds-within-words-a-structural-world-building#:~:text=World,with%20an%20entire%20fictional%20universe)). With generative methods, your world can grow and change autonomously, surprising even you, the creator.

- **Snap! and Block-Based Coding**: Snap! is a blocks-based programming language (building on the idea of Scratch) designed to be easy to learn yet powerful. In Snap!, you drag and snap together puzzle-piece blocks instead of writing text code. This visual approach removes tricky syntax barriers, letting you focus on logic and creativity. In fact, block-based languages like Snap! have proven to be an effective tool for introducing computational thinking to learners ([Smith-CameraReadyv4](https://intellimedia.ncsu.edu/wp-content/uploads/sites/42/smith-icids-2020.pdf#:~:text=to%20engage%20K,effective%20tool%20for%20introducing%20computational)). 

> **NOTE:** We’ll use Snap!’s Lisp-like notation for examples – essentially writing Snap! code in a text form with parentheses – to illustrate programs clearly. We recommend you accompany these with illustrations: @Izzy, @Alex, and @Malcolm 

- **Computational Thinking**: The mindset that underpins coding – breaking down problems, spotting patterns, designing step-by-step solutions, and thinking abstractly. It’s “the thought processes involved in formulating problems and their solutions so that the solutions are represented in a form that can be effectively carried out by an information-processing agent” [(Computational Thinking and CS Unplugged- CS Unplugged)]([https://www.csunplugged.org/en/computational-thinking/#:~:text=%3E%20,Cuny%2C%20Snyder%2C%20Wing%2C%202010](https://www.csunplugged.org/en/computational-thinking/#:~:text=%3E%20,Cuny%2C%20Snyder%2C%20Wing%2C%202010))) (in our case, the computer). In simpler terms, you'll learn to think like a programmer: splitting the task of story-writing into smaller tasks a computer can handle (like generating characters, deciding outcomes, etc.). This doesn’t make storytelling impersonal – instead, it gives you new superpowers to **create** and explore possibilities that would be impossible to manage by hand.


### Hands-On Exercise: Your First Generative Story Snippet

Let’s dive in with a small taste of generative storytelling. We’ll use Snap! to create a single line of a story that changes each time you run it. Follow these steps:

1. **Open Snap!** – Go to the Snap! website (or launch the Snap! app) and start a new project. You should see an empty scripting area and some block categories (Motion, Looks, Control, Operators, etc.).
2. **Add a Say Block** – Click on the “Looks” category (purple blocks) and drag out a `say` block into the scripting area. In Snap!, the default sprite (an arrow triangle) can “say” text in a speech bubble. Click inside the `say` block’s text input and type a simple sentence, e.g., `"Once upon a time..."`. This block will make the sprite display that text when activated.
3. **Incorporate a Random Element** – To make the line generative, let's add a random number to it. Click the “Operators” category (green blocks) and find the `pick random ( ) to ( )` block. Drag it and snap it into your `say` block’s text, replacing a part of the sentence. For example, you could change the `say` text to `"[ ] knights ventured into the cave."` and insert the `pick random 1 to 10` block into the `[ ]` slot. Now the sentence reads something like “`__ knights ventured into the cave.`”, with a random number filling in the blank.
	>**Note:** this won't work quite work as we need to join and are now only saying random numbers :D
4. **Combine Text** – We need to join the random number with the rest of the sentence. Snap! provides a `join` block (also in Operators) that concatenates two pieces of text. Drag out a `join` block. In its left slot, place the `pick random 1 to 10` block. In the right slot, type `" knights ventured into the cave."` (Note: You must leave a space before the word "knights"). Next, put this `join` block inside the `say` block’s text input (replacing the placeholder we had). Now the `say` block contains a compound input that will form our sentence.
5. **Run the Code** – In the orange Control section, you can get a "when a green flag clicked" block and click it to the top of your  "say block". Now, click the green flag (above the stage, to the right) or simply click your `say` block to execute it. The sprite should "speak" a line like “5 knights ventured into the cave.” If you run it again, you might see “1 knights ventured into the cave.”, then “9 knights ventured into the cave.” Each run picks a random number, changing the story detail. Congratulations – you’ve created a tiny piece of generative story!

In Snap’s Lisp-like notation, the final script would look like this:

```scheme
(say (join (rand 1 10) " knights ventured into the cave."))
```

This code uses `random` to pick a number between 1 and 10, joins it with the phrase, and then says the combined string. Even this one-liner hints at how code can introduce variability in storytelling.

### Quiz (Self-Evaluation)

- **Q1:** In your own words, what is _generative storytelling_ and how does it differ from a traditional static story?
- **Q2:** Why might a blocks-based language like Snap! be a good choice for a beginner creating a storytelling program? _(Hint: Think about the advantages of dragging blocks vs. typing code.)_
- **Q3:** Computational thinking involves breaking down problems. Can you identify one sub-problem of storytelling that we might tackle with code (for example: generating a character name, deciding a plot direction, etc.)?

Reflect on these questions and discuss or jot down answers. They will help ensure you grasp the foundational ideas as we continue.

### Project Component: **Story Seed** – Setting the Stage

Every great story begins with a setting and a main character. For this project task, you'll create a simple starting point for your generative world:

- **Define Your World:** Think of a theme or genre for your story world (fantasy kingdom, sci-fi galaxy, mystery town – whatever excites you). Also decide on a hero or main character for your tale. Jot down a couple of key details: e.g., _Hero Name_, _Home (setting)_, maybe an interesting trait of the world.
- **Introduce the World in Snap!:** Using the `say` block, make the sprite narrate one or two introductory sentences about your world. For now, you can hard-code this introduction. For example, you might have: `say "Once upon a time in the ancient land of Aerilon, a young hero named Aria was born."` This sets the scene. (If you want to be fancy, you can use a `join` and a `random` as we did above to add one small random detail, but it’s optional at this stage.)
- **Use a Variable (Optional):** You’ll learn about variables in the next lesson, but if you’re curious, you can get a head start. Try making a variable for the hero’s name or the world’s name and use it in your sentence. For instance, create a variable **HeroName** and set it to `"Aria"`, then use `say (join "Once upon a time in the ancient land of Aerilon, a young hero named " HeroName " was born.")`. This way, if you ever change the hero’s name variable, the intro line updates automatically.
- **Run and Save:** Play your intro by clicking the green flag. Even though it’s static right now (aside from any little random touch you might have added), it’s the seed from which your generative story will grow. Save your Snap! project (give it a name like “MyStoryWorld_Lesson1”). We’ll be building on this project in each lesson, so keep it handy.

Great work – you’ve planted the first seed of your story world! From here on, each lesson will expand on this, making your story more interactive and alive. Feel free to get creative with your intro text. The more vividly you imagine your world now, the more engaging your generated stories will be later. On to Lesson 2, where we give your world some characters and memory!

---

## Lesson 2: Characters and Variables – Giving Life to Your World

### Introduction

Stories thrive on **characters**. Now that you've set the stage, it's time to bring your characters to life. In a world of code, how do we represent a character’s changing attributes – like their name, health, or magical powers? The answer is through **variables**. Think of variables as little treasure chests that can hold information. Just as a character in your world might carry a sword or a secret, your program carries data in variables. In this lesson, you'll learn to use variables to make your story more dynamic and personal. We’ll start by giving your hero a name that the program can remember and use, and perhaps even a trait that can change as the story unfolds. With variables, your story gains a memory – a way to keep track of details as the adventure progresses. _(If you skipped Lesson 1, no worries. You can jump in by imagining a simple scenario and a hero, and creating a new Snap! project for this lesson’s exercise.)_

### Key Concepts

- **Variables**: In programming, a variable is like a container or a labeled box that stores a piece of information. This information could be a number, a piece of text, or other data. You can change what's inside the box, and the variable will then hold the new value – hence the name "variable". In storytelling terms, think of a variable as a character’s attribute or a world detail that might change. For example, a variable `heroName` holds the hero’s name. If the hero earns a title, we could update `heroName` to include it (from "Aria" to "Aria the Brave"). Variables let our program _remember_ and update important story details.
- **Data Types**: Variables can hold different kinds of data. Two common types are **strings** (text) and **numbers**. For instance, `heroName` would be a string ("Aria"), while a `heroAge` or `heroScore` could be a number (16, or 100). In Snap!, you don’t have to declare the type – a variable can hold text, numbers, or even more complex data like lists. This flexibility is convenient in a storytelling context (e.g., a variable can hold "dragon" or 5 interchangeably).
- **Using Variables in Snap!**: Snap! (like Scratch) provides easy blocks to create and set variables. When you make a new variable in Snap!, a block with the variable’s name appears, which you can use to get or set its value. You’ll commonly use the `set [variable] to ___` block to give a variable an initial value, and the `change [variable] by ___` block to modify numerical variables. In code examples, we will denote variables in brackets for clarity, like `[heroName]`. Using variables in your story code means you don’t have to rewrite text or numbers in multiple places – you just change the variable, and every block that uses it will reflect the update.

### Hands-On Exercise: Introducing a Hero with Variables

Let’s enhance your story’s introduction by using variables for the hero’s details. We’ll create a variable for the hero’s name and one for a characteristic, then use them in a sentence.

6. **Create a Hero Name Variable**: In Snap!, click on the “Variables” category (usually orange). Click “Make a Variable”. Name it `heroName` (and ensure it's set for "All sprites" so it’s global). A checkbox for the variable will appear – you can uncheck it if you don't want the value displayed on the stage. Snap! will also create a block labelled `heroName` and blocks like `set [heroName] to ___` and `change [heroName] by ___`.
    
7. **Assign a Name**: Drag out a `set [heroName] to ( )` block. In the blank, type the name of your hero in quotes, e.g., `"Aria"`. This line of code stores the text "Aria" in the variable heroName. (If you want the name to be dynamic, you could later replace this with an `ask` block to have the user input a name, but we’ll cover user input in Lesson 10. For now, we’ll set it directly or you could even use a `pick random` from a list of names if you’re feeling adventurous.)
    
8. **(Optional) Create a Trait Variable**: Let’s say you want to give your hero a trait, like strength or magic. Make another variable, e.g., `heroStrength`. Use a `set [heroStrength] to ( )` block to assign it a value. This could be a fixed number like `5` (representing moderate strength) or you could inject some randomness: e.g., `set [heroStrength] to (pick random 1 to 10)` to give the hero a strength level that changes each run. This numeric variable could influence the story later (like success in battles).
    
9. **Use Variables in the Story Text**: Now, modify your story introduction to include these variables. Go to the Looks palette and get a `say ... for 2 seconds` block (using the timed version ensures multiple sequential says will appear one after the other). Click inside its text input. We’ll construct a message using `join` blocks to insert variable values into the sentence. For example: use a `join` to combine `"Meet "` and the variable `heroName`, yielding something like "Meet Aria". Nest that inside another `join` to add more text, like `"Meet Aria, a brave hero."`. Alternatively, do it in pieces: one `say` block for the first sentence and another for the next. For instance:
    
    - First `say`: `"Meet " + heroName + " – the hero of our story."`
    - Second `say`: `"Strength: " + heroStrength` (if you made the strength variable).  
        In Snap! terms, you might do:
    
    ```scheme
    (say (join "Meet " [heroName] " \u2013 the hero of our story.") for 2)
    (say (join "Strength: " [heroStrength]) for 2)
    ```
    
    The special `\u2013` here represents an en dash (just for stylistic text – you can simply use a hyphen or comma in plain English). What this code does: the first line says, for example, "Meet Aria – the hero of our story." for 2 seconds. The second line then says "Strength: 7" (if heroStrength was 7). Snap! will execute them in order, creating a brief pause for each line.
    
10. **Stack and Run**: Make sure the `set [heroName] ...` (and any other `set` for traits) blocks are placed **before** the `say` blocks in your script. The variables should be assigned their values _first_, then used in the story text. A common practice is to do all your setup at the very top when the green flag is clicked. For now, you can just put these in sequence. Click the green flag to run. You should see your introduction now using the variable values. If you chose to randomize `heroStrength`, run it a few times to see the number change while the name stays the same.
    

Now your program isn't just telling a static intro – it's referencing stored information. If you change `heroName` to "Luna" and run again, the output automatically updates to "Meet Luna – the hero of our story." Without variables, you'd have to retype the name everywhere; with variables, one change propagates through. You’ve given your story a form of memory.

### Quiz (Self-Evaluation)

- **Q1:** What is a variable in programming, and how is it similar to or different from a variable in math class?
- **Q2:** In your story code, you used a variable for the hero’s name. How would using a variable be beneficial if you wanted to allow the player to choose the hero’s name?
- **Q3:** Can you think of three different pieces of information about a character or world that might be useful to store in variables for a story? _(For example: hero’s health, current location, an inventory item, a companion’s name, etc.)_
- **Q4 (Challenge):** If you set `heroStrength` using `pick random 1 to 10`, what range of values can `heroStrength` take? And what Snap! block would you use to increase `heroStrength` as the story progresses (say the hero finds a power-up)?

Consider these questions to ensure you understand how variables work and why they're powerful in making your story flexible.

### Project Component: **Character Profiles** – Bringing Your Hero to Life

Time to integrate variables into your evolving story project:

- **Add the Hero’s Name**: Open your saved project from Lesson 1 (or create a new one if you’re starting fresh). Use the **heroName** variable to store your main character’s name. Replace any hard-coded mention of the name in your story text with the variable. For example, instead of `"Aria"` directly in the text, use `join "Meet " heroName` so that it pulls from the variable.
- **Add a Character Trait**: Create at least one more variable related to your hero or world. It could be `heroStrength`, `heroWisdom`, `treasureCount`, `dayCount` – anything that might play a role as the story unfolds. Initialize it (give it a starting value). If it’s a number, you might set it deterministically (e.g., heroStrength = 5) or randomly (heroStrength = random 1–10). If it’s text, maybe set it to a descriptor like heroTitle = "the Brave".
- **Incorporate into Narrative**: Update your introduction or add a new line in the story that uses this variable. For instance, “Strength: 5” or “Aria’s wisdom is unmatched in the village.” By doing this, you’ve now tied a piece of narrative to a variable’s value. Later, if the variable changes, the narrative can reflect that change.
- **Test and Tweak**: Run your story to ensure it reads correctly. If the text feels awkward (for example, if you see something like “Aria the hero” with double spaces due to how join was used), adjust the joining or punctuation around your variables. Minor fixes like adding a space inside the string or using separate say blocks can help format the output nicely. This is part of the **refinement** process that every coder-author goes through.

By completing these steps, you've set up a **character profile** in code. Your hero is now not just a concept in your head, but a variable-driven entity in your program that can evolve. In the next lesson, we'll introduce decision points so your hero (and program) can make choices, adding true interactivity to your narrative. Keep your project saved – we’ll build on it further!

---

## Lesson 3: Decisions and Consequences – Using Conditionals

### Introduction

Every great story has moments of decision: forks in the road, choices that lead to different consequences. Should the hero take the left path into the dark forest, or the right path toward the snowy mountains? Will the detective confront the suspect, or gather more clues first? In this lesson, we give your story the power of **choice** using _conditionals_. A conditional is a programming structure that asks a yes/no question (a boolean condition) and, based on the answer (true or false), decides which path to follow. By introducing conditionals, your generative story can branch into multiple outcomes, making it dramatically more engaging and immersive. You’ll learn to code “if/else” scenarios where your program will do something _if_ a certain condition is met, or do something else otherwise. This is how we bring **drama and consequence** into our coded world. _(If you’re joining at this lesson, you can still follow along by creating a quick scenario with a variable or two. For example, make a `heroStrength` variable and set it to a value, since we’ll use that in our examples.)_

### Key Concepts

- **Conditionals (If/Else Statements)**: A conditional is like asking a true/false question to the program. It’s written as an **if** statement (and often an **else** part). For example: _if_ the hero’s strength is greater than 5, _then_ slay the dragon, _else_ run away. In Snap!, conditionals come in two flavors: the `if` block (which executes code only if a condition is true) and the `if-else` block (which has two sections – one for when the condition is true, and another for when it’s false). Using conditionals means your code can **branch**, creating different storylines or outcomes. This introduces non-linearity; your narrative can take multiple paths depending on variables or random events.
- **Boolean Logic**: The conditions themselves are questions that have a boolean value – **true** or **false**. These questions use comparison operators (and sometimes logical operators). For instance, `heroStrength > 5` is a condition that is true if heroStrength is greater than 5, false otherwise. Common comparison operators include `=`, `≠` (not equal), `>` (greater than), `<` (less than), and their “or equal to” versions. You can also combine conditions with logical operators like **and**, **or** (e.g., `(weather == "raining") AND (hasUmbrella == false)` is true only if it's raining and you have no umbrella). In storytelling, a condition might be something like “hasKey is true” or “monsterCount == 0”. Mastering boolean logic allows you to encode the rules and logic of your story’s world (e.g., “if the door is locked AND hero has the key, then open it”).
- **Branching Narratives**: By using conditionals, you effectively create branching narrative paths. This is akin to a Choose Your Own Adventure book where the reader’s choices lead to different pages. In our case, the “choice” can be driven by the program’s logic – maybe a random outcome or a previously stored variable. Emphasizing computational thinking, you are teaching the program to _decide_ based on data. This adds depth to world-building: the same world can have different stories depending on circumstances. It’s important to plan these branches so that each is coherent. In modular lesson style, even if you haven't built a full story yet, you can practice with a mini-scenario that branches, which later can plug into your larger narrative.

### Hands-On Exercise: Coding a Story Fork with If/Else

Let’s create a simple branching event in your story. Suppose your hero encounters a dragon. The outcome might depend on the hero’s strength. We’ll use a conditional to decide whether the hero defeats the dragon or has to flee.

11. **Set the Scene**: Ensure you have a scenario ready in your Snap! project where a decision would make sense. For example, continue from the introduction: “A fearsome dragon stands in the hero’s way.” You can add a `say` block to narrate this setup.
12. **Define the Condition**: Decide what variable or condition will influence the outcome. We’ll use `heroStrength` for this example. We want: if heroStrength is above a certain threshold, the hero wins; otherwise, they lose (or choose a safer option). Think of an appropriate threshold. For instance, if strength is out of 10, maybe >5 means success.
13. **Use an If/Else Block**: Go to the Control category (gold blocks in Snap!). Drag out an `if else` block (in Snap!, it might say "if % then; else" with slots to drop blocks into). The block has a hexagon-shaped slot at the top for the condition. Now go to Operators (green) and grab a `> ( ) ( )` block (greater-than). Plug it into the hexagon. In the left side of `>`, put the variable `heroStrength` (drag the orange `heroStrength` block). In the right side, type `5` (or your chosen threshold). Now you have a condition: “if heroStrength > 5”.
14. **Fill in the Outcomes**: The `if/else` block has two sub-stacks – one right below the if (for the true case) and one in the else area (for the false case). In the first, drag a `say ... for 2 seconds` block and make it say the outcome for a strong hero, e.g., `"With a mighty strike, the hero slays the dragon!"`. In the else part, add a `say ... for 2 seconds` block with the other outcome, e.g., `"The hero is overpowered and flees to safety."`. You can add more blocks inside each branch if you want (for example, maybe reduce heroHealth variable if one existed, or broadcast an event – but we'll keep it simple for now).
15. **Integrate and Run**: Place this if/else block in your script at the appropriate point after the dragon encounter is introduced. Make sure it's connected in the sequence (Snap! will execute blocks top to bottom, and within the if/else it will choose one branch). Now click the green flag to run your story. If `heroStrength` is above 5, you should see the victory message; if it’s 5 or below, the fleeing message. Try adjusting `heroStrength` (or rerun if you set it random each time) to test both branches. For example, if you set `heroStrength` to 3 at the start, the hero should flee. If you then set it to 8 and run again, the hero should slay the dragon. You’ve created a dynamic branch!

In Snap!’s Lisp-like pseudo-code, the structure might look like:

```scheme
(if (> [heroStrength] 5)
    (say "With a mighty strike, the hero slays the dragon!")
    (say "Outmatched, the hero flees to safety."))
```

This reads: if heroStrength > 5, say the first message; otherwise, say the second. You can replace the condition or messages to fit your story scenario. The key is that the program is now making a decision based on data, altering the storyline.

### Quiz (Self-Evaluation)

- **Q1:** Explain what the condition `(heroStrength > 5)` means in plain English. What happens if the condition is false?
- **Q2:** Give an example of a real-life decision that could be modeled with an if/else. _(For instance: "If I have enough money, I will buy a gift; else I will save up a bit more.")_
- **Q3:** How would you implement a three-way branch (for example, an outcome if heroStrength is high, a different outcome if it's medium, and another if it's low)? What structures or additional logic might you use in Snap! for that?
- **Q4:** Why is it important to consider all possible outcomes of a condition in your story? _(Hint: Think about what happens if none of the conditions for an if/else are met – or rather, ensure that your conditions cover all logical possibilities so the story always has a path.)_

These questions reinforce understanding of conditionals and branching. Try to answer them without peeking at your code.

### Project Component: **Branching Paths** – Adding a Plot Decision to Your Story

Now it’s time to enrich your world with an actual branching plot point:

- **Identify a Decision Point**: Review the story you have so far. Find a moment that could have two (or more) outcomes. It could be a challenge (like our dragon fight example, or a riddle the hero must answer), a character interaction (does an NPC friend help you or not?), or a simple environmental event (a stormy night vs. a clear night). If your story is still very minimal, you can invent a small scenario now just to practice branching.
- **Choose the Condition**: Decide what will control the branch. This might be a variable (like heroStrength, hasKey, trustLevel, etc.), or it could be a random chance (e.g., 50/50 chance of something). It could even be user input (though we’ll formally cover input in Lesson 10). Set up any needed variables or random values at the appropriate place. For example, you might create a boolean variable `hasMagicAmulet` and set it true/false earlier in the story (maybe randomly: 20% chance found in a treasure chest).
- **Implement the Conditional**: Use an `if` or `if-else` block to branch the narrative. Write the outcomes for each branch using `say` blocks (or even calling custom blocks if you want to organize it, though that’s Lesson 6’s focus). Ensure each branch logically follows from the condition. For instance: _if_ `hasMagicAmulet` is true, then “The amulet protects the hero from the fire.” _else_ “Without protection, the hero is burned by the dragon’s fire.” Be as creative as you like with the outcomes — the goal is to make the world respond to its state.
- **Test Both Paths**: It’s crucial to test that both (or all) branches work correctly. If the condition is based on a variable, try setting that variable manually to force each outcome (e.g., set hasMagicAmulet to true and run, then false and run). If it’s random, you might have to run multiple times to see each result, or temporarily change it to a guaranteed outcome for testing (like if using random 1–100 < 20 for 20% chance, change to < 101 to force true, then < 0 to force false, just for testing). Make sure the narrative still flows after each branch – perhaps the story can converge back to a common storyline, or maybe it leads to different endings.
- **Modular Story Note**: Each lesson’s addition should stand alone and integrate. If someone only does this lesson, their mini-story with a branch should still function. To that end, ensure that any variable or condition you use is given a value within this lesson’s scope (for example, if using heroStrength but they didn’t do lesson 2, instruct them to `set [heroStrength]` at the start here). In your project, since you have been following along, you already have those in place from prior lessons. Just be mindful to initialize anything new you introduce.

By implementing this branching path, your generative world gains complexity and richness. Now the story can unfold in multiple ways, increasing its replay value and depth. Save your project after adding the conditional logic. In the next lesson, we’ll explore loops to handle repetitive patterns in stories – another key to making your world feel alive. Keep the creativity flowing!

---

## Lesson 4: Loops of Adventure – Repeating Patterns in Stories

### Introduction

Have you noticed how some tales have repeating patterns or events? Many myths and fairy tales follow the "rule of three" – three challenges, three siblings, three wishes. Epic journeys often involve traveling from town to town, day after day. These repetitions give rhythm to a story. In coding, when we want to repeat actions or create patterns, we use **loops**. A loop allows a piece of code to run multiple times automatically, so we don't have to write it out over and over. In this lesson, you'll learn to use loops to add structure and repetition to your generative story. This could mean making your hero attempt a task several times, cycling through days of a long journey, or listing multiple items. Loops are a powerful way to expand your world without expanding your code length – write a bit of code once, and have it create _many_ outputs. Embrace the rhythm of repetition in both story and code. _(New to the course at this point? You can still enjoy this lesson by creating a quick stand-alone loop scenario, like printing the days of an adventure. We’ll explain everything from scratch for loops.)_

### Key Concepts

- **Loops (Iteration)**: A loop is a construct that repeats a block of code a certain number of times or until a condition is met. Snap! provides a few types of loops: `repeat (N)` which runs the enclosed blocks N times; `forever` which repeats indefinitely until you stop the program; and `repeat until (condition)` which loops until a given condition becomes true. There’s also a `for` loop block in Snap! (e.g., for a variable from 1 to N) which is handy for counting loops, but if it’s not available, you can emulate it with a counter variable inside a `repeat`. Using loops embodies the computational thinking concept of **iteration** – executing steps repeatedly, which is great for processes that have a cyclic nature (like simulating days passing or multiple attempts to solve a puzzle in the story).
- **Loop Control and Counters**: Often, we want to know which iteration of the loop we’re on (first time, second time, etc.). We use a **counter** variable for this. For example, we might set a `day` variable to 1, then loop while increasing `day` to simulate passing days. Inside the loop, we can use the counter in our output (like saying "Day 1", "Day 2", etc.). It’s important to properly initialize counters (e.g., start day = 1) and update them (e.g., day = day + 1 each iteration) to avoid infinite loops or logic errors. Snap!’s `repeat (N)` loop will automatically iterate N times, but if you need a more custom loop (like repeating until a condition), a manual counter helps.
- **Patterns and World-Building**: In stories, repetition can emphasize themes or build tension. In our generative context, loops can be used to: make the hero perform a task multiple times (maybe attempt unlocking a safe with 3 tries), list a series of items (the treasures found, one by one), or simulate recurring time cycles (each loop is a day passing in the narrative ([Smith-CameraReadyv4](https://intellimedia.ncsu.edu/wp-content/uploads/sites/42/smith-icids-2020.pdf#:~:text=Digital%20storytelling%2C%20which%20combines%20traditional,and%20creative%20exploration%20of))). By combining loops with randomness or conditionals, you can create rich patterns – e.g., each day the weather might be randomly determined, or each of three trials has a different challenge. Loops also keep code tidy: if three trials are similar in structure, one loop with a counter is cleaner than copy-pasting the code three times.

### Hands-On Exercise: Adding a Repeating Cycle to Your Story

Let’s implement a simple loop in your story to illustrate the passage of time. Suppose after a big event, your hero embarks on a journey that lasts several days. We’ll use a loop to narrate a short snippet for each day of travel.

16. **Decide on the Loop Context**: Insert a narrative moment in your story where repetition makes sense. For example, after leaving their home village, the hero travels for 3 days to reach the mountains. During each day, something minor happens (which we can narrate generically or with slight variation).
17. **Initialize a Counter (if needed)**: If you want to number the days, create a variable `day` (if you haven't already) and set it to 1 before the loop starts. This is our day counter. For example: `set [day] to 1`.
18. **Use a Repeat Loop**: Go to the Control category and drag out a `repeat (10)` block. Change the 10 to the number of iterations you want – in our case, 3 (for 3 days). Place it in your script where the journey starts. Everything inside this block will execute that many times.
19. **Narrate Inside the Loop**: Inside the `repeat` block, we’ll add a couple of actions that happen each loop. For instance, have the sprite say something like: `"Day X: The hero continues the journey..."` where X is the day number from our counter. To do that, use a `say ... for 1 second` block. Inside it, build the string using `join`: `"Day "` joined with the `day` variable, then joined with `": The hero travels onward."` (the colon and text). This will produce outputs like "Day 1: The hero travels onward." the first time, then Day 2, etc.  
    Next, after narrating, you might add a small random event each day to spice it up. For example, inside the loop after the first say, you could use an `if` with a random chance: 20% chance say "It rains." or else nothing. Or pick a random minor event from a list of possibilities (bird sings, finds a coin, etc.). This is optional, but shows how loops combined with randomness can create varied repeated scenes.  
    Finally, at the end of the loop body, increment the day counter: use `change [day] by 1`. This will ensure the `day` variable goes 1, 2, 3,... with each loop iteration. In Snap!’s block form, it will automatically execute this each time through.
20. **Close the Loop and Continue**: After the loop block, you can have the story proceed to the next major scene (e.g., "At last, on Day 4, the hero reaches the Mountain of Destiny."). That concluding line would be placed after (below) the repeat block, so it happens after the loop finishes. Remember to perhaps reset or not use the `day` variable beyond this if not needed further, or you could leave it as a record of total days traveled.
21. **Run and Observe**: Click the green flag and watch the loop in action. You should see the Day 1, Day 2, Day 3 messages in sequence. If they flash by too quickly, make sure you used `say ... for 1 sec` (or increase the duration) so you can read them. If you included a random daily event, you’ll see some days with an extra detail and some without, depending on the randomness. This replicates the feel of a journey with routine and some surprises.

The pseudo-code for a 3-day travel loop might look like:

```scheme
(set [day] 1)
(repeat 3
    (say (join "Day " [day] ": The hero travels onward.") for 1)
    (if (< (rand 1 100) 30)
        (say "A peaceful day passes with no incident." for 1))
    (change [day] by 1))
(say "After days of travel, the hero reaches the destination." for 2)
```

In this snippet, the hero travels onward each day, with a 30% chance each day that an extra line is said (in this case, a note about a peaceful day – you could make it something interesting instead). The loop handles the counting and repetition. The final `say` after the loop gives a conclusion to the journey segment.

### Quiz (Self-Evaluation)

- **Q1:** What is the benefit of using a loop instead of just duplicating the same `say` block multiple times for each day?
- **Q2:** If you set a `repeat (5)` loop, how many times will the loop’s body execute? What if you nest one repeat loop inside another (a more advanced concept known as a nested loop)? _(Not required in our story, but consider: a nested loop could be used if, say, each day the hero meets 2 people, you could loop days and inside that loop, loop through people.)_
- **Q3:** In the loop example above, why did we use `change [day] by 1` inside the loop? What would happen if we forgot that step?
- **Q4:** Think of a storytelling scenario for a loop: describe in one sentence a repetitive event in a story that could be coded with a loop. _(For example: "The hero tries three times to guess the creature’s name." or "The wizard brews a potion, stirring it 5 times while adding ingredients.".)_

Answering these will help solidify your understanding of loops and how they apply to your story.

### Project Component: **Rhythms of the World** – Incorporating a Loop in Your Story

Now, integrate a meaningful loop into your generative story project:

- **Choose a Repetitive Element**: Identify something in your story outline that repeats. If you don’t have something obvious, consider adding a mini-sequence. Ideas: the hero visits a series of locations (town1, town2, town3), undergoes multiple trials or tests, spends a week traveling or training, or lists inventory items found during an adventure.
- **Set Up the Loop**: Determine the number of repetitions or whether it’s open-ended. Create any counter variables needed (like `day`, `trial`, etc.) and initialize them before the loop. If the number of repetitions is fixed and small, you can use `repeat (N)`. If it depends on a condition (e.g., repeat until the hero finds a special item), you might use `repeat until (foundItem)` with appropriate logic to break out of the loop (this is more advanced, so a fixed count is fine for now).
- **Write the Loop Content**: Inside the loop, narrate the repeating event. Use the counter variable in the narration if it adds clarity (e.g., "Trial 2: ..."). Incorporate some variation to keep it interesting – perhaps using a random pick from a list of small descriptions for each iteration, or changing a variable slightly each time. For example, each day of travel, decrement a `foodSupply` variable and include it in the text ("Food remaining: X days worth"). This will connect the iterations and state changes.
- **Continue the Story**: After the loop, have the story move on to the next major plot point, acknowledging the end of the repetitive section. For example, "After 7 nights, the full moon rises and the cycle is complete," or simply "Finally, the week of training ends." This gives a sense of closure to that loop segment in the narrative.
- **Test the Integration**: Run your story and watch the loop segment carefully. Does it repeat the correct number of times? Are the messages displaying in order and at a readable pace? If something seems off (too fast, wrong count, etc.), adjust the loop parameters or add a `wait` if needed. Ensure that any variables you use in or around the loop (like the counter) are properly initialized and updated, and consider resetting them afterward if they won’t be used later (to avoid confusion in subsequent runs).

By adding this loop, your world gains a **sense of scale and time**. Repetitive structures can simulate the passing of time, multiple attempts, or collections of items/characters in your story. You’ve now touched on one of the core techniques in programming that shines in storytelling: doing more with less code. Save your project with the new changes. Next, in Lesson 5, we'll introduce lists to manage collections of elements – which will pair wonderfully with loops for even richer story generation. Keep up the great work!

---

## Lesson 5: Enchanting Lists – Managing Collections of Story Elements

## Lesson 6: Crafting Reusable Magic – Custom Blocks (Functions) for Story Patterns

### Introduction

As the architect of your story world, you’ve now built a lot of moving parts: variables tracking state, conditionals branching paths, loops handling repetition, and lists providing rich content. At this stage, you might notice certain patterns in your code. Perhaps you tell a creature encounter story in a similar way in multiple places, or you format dialogue with a repeated style. In programming, when we see a pattern we want to reuse, we create a **function** (in Snap!, a **custom block**). Functions are like the _spells_ or _recipes_ of coding – write the steps once, then invoke them whenever needed. This not only saves time, but makes your code cleaner (following the DRY principle: Don’t Repeat Yourself) and easier to adjust (change the function in one place instead of many). In Snap!, we can define our own blocks for any behavior or calculation we want. In this lesson, you’ll learn to create custom blocks that encapsulate pieces of your story’s logic. This adds a layer of **abstraction** to your project – treating a whole sequence of actions as one higher-level action – which is a key computational thinking skill. It’s like defining a new verb for your storytelling language (e.g., “describeCreature” or “showOutcome”) and then using it as needed. Let’s open our spellbook and start crafting some reusable magic! _(No prior lessons required specifically, though building a custom block is easier if you have some repetitive task in mind. Stand-alone learners can follow by making a simple function in Snap! regardless.)_

### Key Concepts

- **Custom Blocks (Procedures/Functions)**: A custom block is a user-defined command or reporter in Snap!. Think of it as grouping a set of instructions and giving that group a name. Later, you can execute that group by calling the block name. There are two types: **command blocks** (which perform actions, like say, change variables, etc., and are shaped like puzzle pieces that attach normally) and **reporter blocks** (which calculate and return a value, shaped like an oval that fits in expressions). In storytelling, many custom blocks will be command-style (since they output text or make something happen), but you might also create reporters for things like generating a random name or constructing a sentence to use. Creating a custom block in Snap! is done via the “Make a Block” button, where you give it a name and define its script.
- **Parameters (Inputs)**: Functions can be more flexible if they take inputs (parameters). For example, a custom block `describeCreature(creatureName)` could take a creature’s name as input and then say a descriptive line about it. With parameters, your block becomes a reusable template that can handle different data each time it’s called. In Snap!, when you make a block, you can add input names (like placeholders) that will appear as orange variables inside that block’s definition. When calling the block, you fill in those inputs. Using parameters encourages **abstraction** – you write code in general terms (like a generic description formula) and plug in specifics (like "dragon" or "goblin") when you call it.
- **Abstraction and Modularity**: By packaging story segments into custom blocks, you structure your project into logical pieces. Each block has a distinct purpose (e.g., one block handles the whole process of the hero finding a treasure, another handles battle outcome). This modular design aligns with clear and concise coding: each piece is easier to manage and test, and the high-level script becomes more readable (like an outline of the story logic, with custom block names summarizing what happens). If you ever need to change how a certain action works, you update the custom block’s definition in one place. This also means each lesson's piece can stand alone better – a custom block is like a mini-program that you could use on its own. Computationally, this is like creating your own toolkit of story-generating functions that can be mixed and matched.

### Hands-On Exercise: Creating a Custom Block for a Repeated Story Action

As an example, let’s say in our story the hero can **encounter a creature** in several places (in the forest, on the road, in a cave). We find ourselves writing similar code each time: pick a creature, describe it appearing, possibly handle a fight outcome. Instead of duplicating that code, we’ll make a custom block `encounterCreature` that does it, and just call it whenever needed.

22. **Identify the Repetitive Pattern**: Decide what sequence of steps you want to encapsulate. In this case, the pattern might be: _choose a random creature from the creatures list, say it appears, then if heroStrength (or some stat) is high enough, say the hero defeats it, else say the hero escapes_. You might have already coded something like this in an earlier lesson.
23. **Create a Custom Block**: In Snap!, click on the “Make a Block” button (often in the Variables palette or in the palette menu). A dialog appears. Choose the type (Command by default, which is what we want for an action sequence). Name it something descriptive, like `encounterCreature`. If you want it to take an input (maybe the location or some difficulty factor), you can add an input by clicking the plus sign next to “Inputs” in the dialog. For now, let's keep it simple – no input, since it can directly use global variables like the creatures list and hero stats. Click OK, and Snap! will open the block editor for you to define what this block does.
24. **Define the Block’s Script**: You’ll see a scripting area with a block header (with your block name and any inputs, if you had them). Now drag the blocks that make up the creature encounter _into this editor_. For example:
    - Use the `item (rand 1 (length of [creatures])) of [creatures]` inside a `set [currentCreature] to ...` (you might need to make a local variable in this script for currentCreature, or you can use a global but local is cleaner – Snap! allows you to create script variables via the orange “script variables” block at top of editor if needed). Alternatively, skip a separate variable and directly say the creature; but let's assume we use `currentCreature`.
    - Then a `say (join "A wild " currentCreature " appears!") for 2` block.
    - Then maybe an if/else: if heroStrength (or some hero stat) > creatureDifficulty (you could assign difficulties to creatures in a parallel list, or use random, but let's just decide something simple: if heroStrength > 5 then hero wins else flees). Inside if: `say "Hero defeats the " + currentCreature + "!"`; else: `say "The " + currentCreature + " was too strong; the hero escapes."`.
    - You can use existing global variables like heroStrength inside this custom block; that's fine. Or you could make heroStrength an input to the block to make it more general (but since heroStrength is global and likely constant across calls, it's fine).  
        Arrange these inside the editor, snapping them in sequence or within the if as appropriate, just as you would in the main script. When done, click the OK or Apply (check) button to save the block definition.
25. **Call the Custom Block**: Now your new `encounterCreature` block will appear in the palette (likely in a new custom category with a color you chose, or under “Variables/Custom”). Back in your main script area, wherever you want a creature encounter to happen, drag out your `encounterCreature` block. It looks just like a built-in block now. For instance, you might put it after a narration like "While traveling through the forest..." then call `encounterCreature` and it will handle the rest. You can call it multiple times if the hero has multiple encounters. Each time, it will execute the same defined steps: pick a creature, narrate, resolve the outcome.
26. **Test the Custom Block**: Run the story and ensure that whenever `encounterCreature` is called, it behaves correctly. You should see the random creature selection and appropriate outcome. If something doesn’t work, maybe edit the block definition (right-click your custom block and choose "edit" to reopen the editor). For example, if the creatures list isn't accessible inside, ensure you didn't accidentally create a local variable with the same name overshadowing it. Or if heroStrength is needed, ensure it's set before calling this block. Tweak until it works reliably.
27. **Use Parameters for Flexibility (Optional)**: If you want to get fancy, you could add a parameter to `encounterCreature` like (strengthThreshold) or (location). For example, maybe in a dangerous area you call `encounterCreature(8)` meaning use 8 as the strength threshold for winning, whereas in a normal area `encounterCreature(5)`. To do that, edit the block, add an input named e.g. `reqStrength`, and use that in your if condition instead of a fixed number. Or maybe pass in `creatureType` to force a specific encounter. However, optional – even without parameters, you gain a lot by encapsulating the logic.

By now, you should see your main program looking simpler. For instance, instead of many lines for an encounter, you have one `encounterCreature` call. If you have other repeated patterns, consider making blocks for them too. Examples: a `showStatus` block that prints out hero’s current stats in a nice format, or a `openTreasureChest` block that randomizes loot from a list and updates inventory, etc. Each custom block is like adding a new tool to your storytelling engine.

### Quiz (Self-Evaluation)

- **Q1:** What are the benefits of using a custom block instead of copying and pasting the same set of blocks whenever you need that behavior? List at least two benefits.
- **Q2:** If you wanted a custom block to greet a character by name, say `greetCharacter(name)`, how would you design it? What would the block do, and what would you pass as an input when calling it? (Write a brief pseudo-code of its definition and an example call.)
- **Q3:** True or False: A custom block can use global variables from your program (like lists or state) just as normal blocks can. Explain your answer.
- **Q4:** In your story, identify one more potential custom block you could create. What would you name it and what specific task or scene would it encapsulate? (This is a thinking/design question – you don’t have to actually implement it now, just recognize the opportunity.)

Reflect on these answers. Being able to articulate the purpose and design of functions is a sign you’re mastering abstraction.

### Project Component: **Spellbook of Functions** – Refactoring Your Story with Custom Blocks

Now, apply this concept to your story project to tidy it up and prepare for further growth:

- **Choose a Story Segment to Abstract**: Look through your current script. Find a chunk of code that does a specific thing and might be useful more than once or just conceptually deserves its own name. Good candidates: the entire process of handling a random encounter (as we did), the sequence for a puzzle or riddle (if you have one), a repetitive format like displaying the result of a battle, or even a setup routine (like initializing variables and lists at the start – though that’s usually run only once, you could still encapsulate setup in a block for cleanliness).
- **Define a Custom Block**: Use “Make a Block” to create a custom block for that segment. Name it clearly, perhaps with a verb. If the segment naturally varies each time, consider adding parameters. For example, `battleOutcome(enemy)` might take an enemy name and then print a story of fighting that enemy. Or `travelTo(place)` might narrate traveling to a given place. If the segment doesn’t need input, just define it to use global context. Implement the block’s script by dragging the relevant code inside the editor. This might involve moving existing code out of your main script into the block definition (don’t worry, you can cut-paste between the main area and the editor). Ensure any variables it needs are accessible (pass as inputs or use globals).
- **Replace Original Code with Block Calls**: Back in your main script, remove or comment out the detailed code that’s now inside the custom block, and instead call the block. Do this at each point needed. For instance, every time you had that encounter sequence, you now just call `encounterCreature`. Or the whole training montage you turned into `trainingMontage` block, just call it once. This should shorten the main script and make it read more like an outline: e.g., "Intro, encounterCreature, travelLoop, encounterCreature, finale". Each custom block stands in for a chunk of narrative logic.
- **Test Thoroughly**: Whenever we refactor code (change structure without changing functionality), testing is crucial. Run your story to ensure it still behaves the same at runtime. If something broke, check if all pieces are being called in the right order and if any needed data isn’t lost. For example, if your custom block needed a list, was that list populated _before_ you call the block? Ordering matters, especially since you might have cut and moved code around. Fix any issues. Use watchers or temporary `say` debug lines inside blocks if needed to see that they are executed.
- **Enjoy Easier Modifications**: Now that you have at least one custom block in place, note how you could easily tweak how that part of the story works by editing the block definition, without touching the rest. For instance, to balance the encounter difficulty, you could adjust one number in `encounterCreature` and that affects all future calls. If you think of an enhancement (like adding a sound effect or visual later in Snap), you could drop it into the block and it automatically rolls out to all uses. This modularity will serve you well as your project grows.

By refactoring with custom blocks, you've effectively **upgraded** your project’s code structure. This is akin to an author breaking a story into chapters or scenes for clarity. Your program is more readable and maintainable. It also demonstrates an understanding of _abstraction_ – one of the trickier but most powerful ideas in computing. Pat yourself on the back: not only are you creating a captivating story, but you're doing it with clean code practices! Save your project (maybe as a new version, like "MyStoryWorld_Lesson6" so you can compare with older one if needed). In the next lesson, we will reintroduce randomness and complexity at a deeper level, possibly exploring probability and more sophisticated generation techniques to make the story even more unpredictable and interesting.

---

### Introduction

As your story world expands, you'll find you have **many** elements: a cast of characters, a trove of treasures, a menu of magical spells, or an array of possible events. To organize this variety, we use **lists**. A list is like a magic bag that can hold a bunch of items in a specific order. Instead of having a separate variable for every single creature or place, we can put them all in one list variable and handle them together. This not only keeps our code tidy but also unlocks powerful techniques: we can pick a random item from a list to introduce a surprise creature, or we can loop through a list to enumerate items ("The hero carries: sword, shield, potion..."). In this lesson, you'll learn to create and use lists in Snap!, which will greatly enhance your generative storytelling. Your world-building will become more **modular and scalable** – want to add a new monster type? Just add one more entry to a list, rather than writing new code. Let’s dive into lists and see how they can make your story more vibrant and varied. _(Starting fresh from Lesson 5? You can still participate by creating a new Snap! project and following along with list examples. You don't need the previous project context to understand lists, though you can certainly imagine a scenario to use them.)_

### Key Concepts

- **Lists (Arrays)**: A list is an ordered collection of items. You can think of it as a numbered list of things. Each item in a list has an index (position) – 1st item, 2nd item, and so on (in Snap! and Scratch, lists are 1-indexed, meaning the first item is index 1). Lists allow you to store multiple values in one variable. For example, a list called `creatures` might contain `"dragon"`, `"goblin"`, `"phoenix"` as its items. In Snap!, lists are first-class data, meaning you can pass them around, make lists of lists, etc., but we'll start simple. Common operations are **add** (insert a new item at the end or a specified position), **delete** (remove an item), **replace** (change an item at a position), and **length** (how many items).
- **Accessing List Items**: To retrieve or use an item from a list, you specify its index. Snap! provides an `item ( ) of [list]` block. For instance, `item (2) of [creatures]` would give `"goblin"` (if goblin is second in the list). You can use the `length of [list]` block to find out how many items are in a list, which is useful for loops or picking the last item. Lists work great with loops – you can loop from 1 to length of list to visit each item (e.g., list all monster names).
- **Using Lists for Generativity**: In generative storytelling, lists are your toolkit for variety. Want a random character name? Put a bunch of names in a list and pick one at random. Want to cycle through a set of clues? Store them in a list and iterate. By separating content (data) from logic, your program can be easily extended: to add a new option, you just extend the list. This is a practice of **data-driven storytelling**. Also, lists can be dynamic – you can start with empty lists and append items as the story progresses (e.g., an inventory list that starts empty and grows when the hero picks up items). Thinking in terms of lists also encourages **modularity** in your code: one piece of code can handle any number of items simply by looping through a list, rather than having multiple duplicates of code for each item. This is both efficient and aligns with clear, concise coding principles (Kansas Star’s clarity and conciseness are reflected when we reduce redundant code).

### Hands-On Exercise: Creating and Using a List in Snap!

Let's make a list of magical creatures and have the story summon a random one to appear, as an example of adding variety.

28. **Create a List Variable**: Go to the Variables category in Snap!. Click “Make a list” (in Snap!, if you don't see this, you can instead create a variable and store a list in it using the `list` block). Name the list `creatures`. Snap! will now treat `creatures` as a list variable. You might see an empty list display on the stage (which you can hide by unchecking it, unless you want to watch it as you add items).
    
29. **Initialize the List**: We need to fill the list with some items. There are a couple of ways:
    
    - **Using the list block**: In the Variables palette or the Operators palette, find a block that looks like `list ( ) ( ) ( )` (it might have empty slots or allow you to add items). Drag that into a scripting area. Click on it to get slots for items. Type `"dragon"` in the first slot, `"goblin"` in the second, `"phoenix"` in the third (you can add more mythical creatures if you want, like "troll", "unicorn", etc. – some Snap! versions let you press a + to add more slots). Now use a `set [creatures] to ( ... )` block, and put this `list (...)` block in the value slot. This assigns the list of strings to your `creatures` variable all at once.
    - **Using add block**: Alternatively, you could create an empty list then use `add (thing) to [creatures]` repeatedly. For example: `set [creatures] to (list )` to initialize an empty list, then `add "dragon" to [creatures]`, `add "goblin" to [creatures]`, etc. Either approach is fine – the result is that `creatures` now contains several items.
30. **Randomly Pick an Item**: Now, let's use this list in the story. Suppose at some point you want a random creature to appear. We will use the list to make that decision. Snap! doesn’t have a direct "pick random item of list" block, but you can combine `item` and `random`: use the `item ( ) of [creatures]` block, and for the ( ) index input, use a `random 1 to (length of [creatures])`. This way, you're picking a random index between 1 and the length of the list, effectively choosing a random item. Construct a `say ...` block that says something like: `"A wild [creature] appears!"` where `[creature]` is replaced by the result of that `item ... of creatures` expression. Concretely, you might do:
    
    ```scheme
    (say (join "A wild " (item (rand 1 (length of [creatures])) of [creatures]) " appears!") for 2)
    ```
    
    Here we nested the join to handle three parts: "A wild ", the random creature name, and " appears!". If that's confusing, you could also do it in two steps: first set a variable `encounter` to `item (rand 1 (length of [creatures])) of [creatures]`, then do `say (join "A wild " encounter " appears!")`. The outcome is that each time this runs, it will announce a random creature from your list. Try running that line a few times; you should see different creatures being named.
    
31. **Loop Through List (Optional)**: To further demonstrate list usage, you might want at some point to list all items. For instance, if the hero is checking the bestiary or scouting the area, you could loop through the `creatures` list and say each name. A simple way: use a `repeat (length of [creatures])` loop, and inside it say `item (index) of [creatures]`, where `index` goes from 1 up to length. In Snap!, you can do this by creating an index variable and incrementing it, or using a `for i = 1 to ...` block if available. But this is optional – the main focus is knowing how to access list items.
    
32. **Use Lists in the Ongoing Story**: Consider integrating the list into your main story flow. For example, if earlier in your story the hero might encounter a creature, replace any static creature name with a random pick from `creatures`. Or if the hero has an inventory, maintain it as a list of items collected (starting empty, then using `add` when something is picked up, and perhaps listing them at some point). We will expand on such dynamic uses later, but it's good to start thinking about where a list can replace a bunch of individual variables or random choices.
    

Run your story with the new list logic. You should notice the difference: instead of always "a dragon appears" (static) or a clunky if-else chain to choose creatures, the list handles it cleanly and you get varied output. Adding a new creature is as easy as adding one entry to the `creatures` list initialization – no code logic changes needed.

### Quiz (Self-Evaluation)

- **Q1:** In Snap!, if you have a list `treasures = ["gold", "gems", "sword"]`, what will `length of [treasures]` report? And what does `item (1) of [treasures]` return?
- **Q2:** How would you get the _last_ item of any list, no matter how long it is? _(Hint: use length... for example, `item (length of [treasures]) of [treasures]`.)_
- **Q3:** Why are lists useful when you want to scale up the amount of content (like more characters or more events) in your story? What would be the downside of using a separate variable for each new piece of content instead of a list?
- **Q4 (Design):** Think of a list you might want in a story context and what it would contain. For instance, a list of place names, a list of NPC dialogues, or a list of possible weather events. How would you use that list in a generative way?

These questions reinforce how to interact with lists and why they are powerful for our needs.

### Project Component: **Variety Pack** – Expanding Your World with Lists

Enhance your story project by introducing at least one list to manage a set of related elements:

- **Identify a Collection**: Look at your story and find a category of things that could be represented as a list. Common ones: a **cast of characters** (e.g., names of villagers, enemies, allies), **inventory items** (things the hero might find), **locations** (places the hero travels through), or even **events** (snippets of scenes that could happen in random order). Pick one that would add richness if it had multiple options.
- **Make and Populate the List**: In Snap!, create a list variable for this collection (e.g., `villagers`, `loot`, `places`). Fill it with a variety of entries. Aim for at least 3-5 items to make the variety noticeable, but you can add as many as you like. For example, `places = ["ancient forest", "lonely mountain", "abandoned village", "underground cave"]`. You can input them via the `list (...)` block as shown in the exercise, or by using multiple `add` steps. Ensure this list is set up early in your program (for instance, at the start when the flag is clicked or at least before you try to use it).
- **Use the List in Story Generation**: Find the point in your story code where this list should come into play. For example:
    - If you made a `places` list, perhaps when describing the journey, instead of a fixed route, you randomly choose the next destination from the list. Or you loop through the list to actually have the hero visit each place in sequence (maybe using a loop to go through all places one by one).
    - If you made a `loot` list for treasures, when the hero opens a treasure chest, randomly select an item from `loot` to present.
    - If you have a `villagers` list, maybe when the hero returns to town, you randomly pick one villager to greet them, or list several villagers that they meet.  
        Use `item (rand 1 (length of [list])) of [list]` for random selection, or a loop for sequential.
- **Maintain Consistency if Needed**: If you randomly pick something from a list but want to **remove** it after (to avoid repetition in the same run), you can use the `delete (i) of [list]` block after using an item. For instance, if a treasure is taken, you might delete it from the `loot` list so it isn't found again. Or if a creature is defeated, remove it from the `creatures` list. Snap! will shrink the list and you can continue using it. This is optional and a bit advanced; only implement if it makes sense and you feel comfortable. You can also simply allow repeats for now.
- **Test the Outcomes**: Run your story multiple times to see the list in action. Do you get varied results where expected? If something isn't working (e.g., maybe you got an "list is empty" error because you tried to access before populating), debug that: ensure list is set up, indexes are correct (remember not to random pick 0 or beyond length), etc. If the outputs are too repetitive or not making sense story-wise, you might add more items to the list or adjust how it's used (for example, maybe weigh random choices by repeating some items in the list or by using ifs for rare events – but that's fine-tuning beyond this step).

By incorporating lists, your project likely feels more **alive** and content-rich. You've effectively taught your program a little bit of _world knowledge_ by giving it collections of things to draw from. This modular content approach will make future expansions easier: you can add to or tweak list items without breaking the overall logic. Save your project. In the next lesson, we’ll learn how to tidy up and reuse code by making custom blocks (functions), which will be especially handy as our project grows in complexity.

---

## Lesson 7: Roll the Dice – Randomness and Probability in Your Story

### Introduction

Up to now, we've used randomness in simple ways (like random numbers or picking random list items). In this lesson, we’ll delve deeper into the **chance** element of generative storytelling. Randomness is the spice that keeps each run of your story unpredictable and exciting, but like any spice, it should be used in the right amount. Too much randomness and your story might become nonsense; too little and it might feel repetitive. We’ll explore how to control randomness with **probability** techniques, making some events rare and others common, to mimic the unpredictability of real life or to create dramatic tension. For example, maybe there's a 10% chance of finding a legendary treasure, or a 1 in 6 chance like rolling a die. You’ll learn how to implement weighted chances in Snap! and how to combine random outputs with logical constraints to keep the narrative coherent. By the end, your world will feel like it has its own roll of the dice governing fate, bringing it closer to a living universe. _(This lesson can stand alone: new participants can open Snap! and try these random experiments separate from an ongoing story if desired.)_

### Key Concepts

- **Random Number Generation**: We’ve used `pick random X to Y`. This gives a uniform random integer in [X, Y]. For finer control, Snap! also can generate random fractions (with the same block if you supply non-integers) or you can use some math to simulate different distributions. The key concept here is **probability**: each outcome has a certain likelihood. With uniform `random 1 to 10`, each integer 1-10 has equal 10% chance.
- **Probability and Conditions**: To implement a probability, you often use a random number then a conditional. For example, to have a 20% chance of something, you can `if (rand 1 to 100) <= 20 then [event]`. Or simpler: `if (rand 1 to 5) = 1 then [event]` (since 1 out of 5 outcomes is 20%). This approach gives you a lot of flexibility: you can adjust the threshold or range to tune probability. You can also simulate weighted choices between multiple outcomes by dividing ranges or using multiple if-else: e.g., 10% one event, 30% another, 60% another by checking ranges 1-10, 11-40, 41-100.
- **Fair vs Biased Randomness**: Sometimes you want all options equally likely (fair), sometimes not. For example, maybe in your story, encountering a common goblin should be much more likely than encountering a rare dragon. If you have a `creatures` list, you could achieve that by including duplicates of "goblin" in the list to naturally weight it, or by using an if after picking to re-roll occasionally if you got "dragon" to make it rarer (though that's clunky). A better approach: separate common vs rare lists or implement a probability check if the random pick is "dragon" and if failing it, override to something else. This is a bit advanced, but worth thinking about: random does not always mean equal chance for everything in crafted experiences.
- **Random Seeds (Advanced)**: We won't go deep into this, but interestingly, randomness in computers is pseudo-random; if you use the same starting seed, you get the same sequence. Snap! doesn't expose seed control easily, but it's worth noting in generative art: sometimes you want reproducibility for debugging ("random" but the same every time until you change a seed). For storytelling, you might not need to worry about this, but if you did, you would conceptually use a known sequence to get repeatable 'random' outcomes. For now, Snap!'s random is fine and unpredictable each run, which is what we want for creativity.

### Hands-On Exercise: Fine-Tuning Random Events

Let's refine an earlier example with probability: the chance of a rare event (say, finding a magical artifact during travel).

33. **Identify an Event to Randomize**: Choose a point in your story where you want to introduce a random event or outcome. A good scenario is something like: while traveling or after a battle, there's a chance something special happens (finding an item, meeting a wanderer, etc.). If you're doing this stand-alone, just imagine a scenario: e.g., "Whenever the hero explores, there's a small chance they discover a secret."
    
34. **Decide the Probability**: Determine how rare or common you want the event. Let's say: 15% chance of discovering a magical amulet during a journey. Representing 15% as a fraction of 100 is straightforward (15/100). We can use `random 1 to 100` for this easily. Alternatively, 15% is like roughly 1 in 6.67, not a round number, so 100 is easier for now.
    
35. **Implement the Check**: In Snap!, use an `if` block for the event. For condition, use `(rand 1 to 100) <= 15`. In the true branch, put the code for the special event. For our example: perhaps `say "Lucky you! The hero discovers a magical amulet by the roadside."` and maybe set a variable `hasAmulet = true`. In the false branch or using an `if` without else, either do nothing (no event happens, just continue story) or you can optionally narrate a normal outcome ("The journey continues uneventfully.").  
    Place this if in the appropriate context, e.g., inside a travel loop or right after a travel description. If stand-alone, just execute it to see the odds.
    
36. **Test Probability by Repeated Runs**: Because 15% is somewhat low, you might need to run multiple times to see the event happen. Try running the script or that section, say, 10 times. Statistically, you might see ~1-2 occurrences in 10 tries (though randomness can vary). If you find either it's too frequent or too rare for your liking, adjust the threshold and test again. Maybe you realize 15% is too high (the special event happens too often, making it less special), so you drop to 5%. Or perhaps it's too low (almost never triggers in testing), so increase to 20%. Finding the right balance is part of the design.
    
37. **Multiple Outcomes with Weights**: Now suppose there are two different rare events: finding an amulet (say 10%) and encountering a wandering sage (5%). We want these to be distinct outcomes with their own probabilities. One way: use if-else chain. For example:
    
    ```scheme
    set roll = random 1 to 100
    if (roll <= 5)
        say "A wandering sage appears and offers wisdom."
    else if (roll <= 15)  // 5% < roll <= 15% covers 10% range
        say "You find a hidden magical amulet on the ground."
    else 
        say "Nothing unusual happens today."
    ```
    
    This scheme first checks the 5% case, then the next 10% (which effectively covers 6-15), else the remaining 85%. Implement something like this in Snap! using nested if (Snap doesn't have explicit else-if, but you can nest an `if` inside the else of another). Make sure the ranges don't overlap and cover all possibilities up to 100. Alternatively, generate a random 1-100 and use multiple separate ifs with careful logic (the chain method is simpler conceptually). Test this by many runs to see both events occur at their roughly intended frequencies.
    
38. **Weighted Random from List**: Another technique: if you have a list of options but want them weighted, you can simulate that by using index ranges or duplicating items. For instance, `creatures = ["goblin","goblin","goblin","dragon"]` would give goblin a 75% chance and dragon 25% if you pick a random item. Or you could maintain a parallel list of weights and do a bit of math (that's more advanced). A simpler approach for now is the duplication method or manual random ranges as above. Consider whether any of your lists in the story should perhaps have biased choices. If so, you can implement it either by adjusting the list content or by doing an if after a random pick that "re-rolls" if an outcome should be rarer (though that's not the best approach statistically). For learning’s sake, perhaps try adding a duplicate entry in a list and see how it affects frequency.
    

### Quiz (Self-Evaluation)

- **Q1:** If you want a 1 in 8 chance of an event in Snap!, what’s one way to code that using `random` and `if`?
- **Q2:** In a random 1 to 100 scheme, what ranges would you use to assign: 5% to outcome A, 20% to outcome B, and 75% to outcome C? (Assume A, B, C cover all possibilities exclusively.)
- **Q3:** Why might you _not_ want every part of your story to be random every time? (Think about story coherence and the role of some fixed elements or state.)
- **Q4:** Suppose you have a list of three monsters: [goblin, troll, dragon]. How could you modify either the list or the selection process to make goblin appear about 50% of the time, troll 30%, and dragon 20%? (There are multiple ways; describe one.)

Answer these to ensure you grasp controlling randomness.

### Project Component: **Luck and Chance** – Enhancing Your Story with Controlled Randomness

Now we’ll enrich your ongoing story by adding or refining elements of chance:

- **Review Current Random Elements**: Look at where you already use randomness in your story. Perhaps you already randomly choose creatures or treasure. Evaluate if the frequencies feel right or if you'd like to bias some outcomes. Jot down any adjustment ideas (e.g., "Dragons should be rarer than goblins" or "Finding the legendary sword should be extremely rare").
- **Introduce a New Random Event**: Identify a spot in your narrative where a random event could add excitement. Some possibilities: a weather event (20% chance of a storm on any given day), a character flaw (occasionally the hero might stumble, adding a setback), an encounter that doesn't always happen (maybe some journeys are peaceful except a lucky/unlucky few). Add an `if random...` structure to implement it. For multiple outcomes, use the chained approach or even random from a weighted list as needed. For example, during the loop of days traveling, add a random check each day for a special encounter as we did in the exercise. Or at the end of the story, perhaps randomly decide which ending epilogue out of two to show (giving a bit of variability to the finale).
- **Adjust Probabilities of Existing Mechanics**: If you have creature encounters or loot drops from previous lessons that were uniformly random, decide if you want to weight them. You can adjust by either changing the list composition or by adding logic. For instance, if `encounterCreature` block currently picks uniformly from the creatures list, you could modify it: perhaps roll a number, and if it's above a threshold, force the creature to a common one. Or simpler, add duplicates to the list (though that approach means if you ever show the whole list somewhere, duplicates would appear; it's purely a trick for random selection). Choose the method that fits your design: if you don't need to list the items anywhere, duplication is quick; otherwise, conditional logic might be better. Implement the changes and comment your code for clarity (e.g., a comment that says "dragon spawn chance = 20%").
- **Playtest Many Times**: Because randomness is involved, it's not enough to run your story once to see if everything's fine. Run it numerous times, and ideally, have each time produce logs or printouts of key random decisions (you can temporarily add `say` blocks or watchers to variables like random rolls to monitor probability). Watch for any weirdness: Does a "rare" event trigger too often? Did you run 10 times without ever seeing something that should happen occasionally? Tweak probabilities as needed. It's a fine balance: you want the player/reader to experience the special things sometimes, but not so frequently that they lose their novelty. Also ensure that if random events alter state (like giving an item), your later story logic accounts for it (for example, if hero randomly finds an amulet and you set `hasAmulet`, maybe later you can use that variable in a conditional to affect an outcome – which is great for coherence!).
- **Ensure Coherence**: After adding more randomness, double-check the narrative still makes sense. One risk of random events is continuity errors. For instance, if a random event gives the hero a key but another random event also independently gives a key, you might end up with multiple keys unless you guard against it. Or if a random event kills a side character, you shouldn't have them appear alive later. These are complex scenarios, but think through any interactions of your random bits with the overall story state. Use flags/variables to mark if an event happened, and conditionally avoid contradictory events. This is pushing into complex territory, but even just brainstorming these possibilities is practicing good computational thinking (anticipating edge cases).

By carefully weaving randomness into your story, you enhance replayability and surprise while striving to keep the story logically sound. You've effectively taught your program the whims of fortune. Save your project with these changes. In the next lesson, we'll tackle maintaining state and consistency even further (which complements the random elements), ensuring that as your story branches and randomizes, it remains a believable world. Keep up the great work – your world is now full of life and unpredictability!

---

## Lesson 8: Keeping Track – State and Memory for Story Consistency

### Introduction

By now, your story can branch in many directions and surprise us with random events. With this complexity comes a challenge: **consistency**. In a good story, if a hero picks up a key in chapter 2, they have it in chapter 5 unless stated otherwise. We achieve this in coding by managing the **state** of our world – using variables and data structures to remember what has happened. In this lesson, we'll focus on techniques to maintain consistency and continuity in generative storytelling. This means setting flags or variables when events occur, updating lists to reflect changes (like removing an item once taken), and then _using those variables later_ to influence the narrative. We touched on this when introducing variables (lesson 2) and conditionals (lesson 3), but now with more moving parts, it's crucial to systematically track things like: Does the hero have the magical amulet they found? Did the villain escape or was he defeated? Which treasures are already collected? We’ll make sure that your program “remembers” and respects these details. This is where computational thinking meets storytelling craft: you're teaching the computer to be a diligent narrator, not forgetting past events and making future events logical. _(This lesson stands alone conceptually; new learners can imagine a scenario with a state to track, even if they haven’t built a full story.)_

### Key Concepts

- **State Variables**: A state variable is any variable that represents something about the current situation or history of the story. Examples: `hasKey`, `villainDefeated`, `treasuresCollected` (could be a count or list), `currentLocation`. Managing state means updating these variables when events happen, and checking them later to determine what happens next. It's good practice to initialize your state variables at the start (e.g., `hasKey = false`).
- **Flags (Boolean variables)**: Often, whether something has happened or not is a yes/no (true/false) situation. We often use boolean flags for these. For instance, `hasKey = true` if the hero obtained the key. Then later `if (hasKey) then ...` to allow unlocking a door. Using clearly named boolean flags is a straightforward way to keep track of significant plot points.
- **Lists as Memory**: Lists can also serve as a record. For example, an `inventory` list can dynamically store items the hero acquires. Then anytime we need to know if the hero has something, we check if it's in the list. Or a `visitedLocations` list could track where the player has been, to avoid revisiting or to alter descriptions on revisit. Managing such lists involves adding items (and possibly removing, if consumable or lost). This is more complex than booleans but more scalable when there are many possible items or elements.
- **Persistence Across Events**: Ensure that when the story transitions scenes (especially if using broadcasts or separate scripts), the state variables persist. In Snap!, global variables naturally persist throughout unless changed. If you used local script variables or custom block inputs to carry state around, ensure the information isn't lost out of scope. Usually, for story state, using global variables or lists is simplest so that anywhere in the program can access the current state.
- **Reset and Replay**: Another aspect of state: when the story ends or restarts, consider resetting state variables to defaults. If you're running multiple trials of your program in one session, Snap! variables might keep their last values unless you explicitly reset or rely on green flag which typically reinitializes if you coded it to (like setting all flags false at start). It's a good practice to have an initialization routine to clear or set up state at the beginning of each run (ensuring each playthrough starts fresh, as we usually expect in a story).

### Hands-On Exercise: Ensuring Consistency with State Tracking

Let's work through a concrete example in a mini-story: the hero needs a key to open a treasure chest. We'll manage a `hasKey` state so the chest outcome is consistent with whether the key was obtained.

39. **Initial State Setup**: At the start of your program (when green flag clicked, or at least before the relevant events), initialize a boolean variable `hasKey` to false. In Snap!, make a variable `hasKey`. Use `set [hasKey] to false` (Snap! might accept the word _false_ or you can use a boolean block from Operators that is a constant false). Alternatively, you can use 0/1 or "yes"/"no", but Snap! supports actual boolean values which is nice.
40. **Key Acquisition Event**: Decide how the hero can get the key. Perhaps there's a random event or a choice. For this exercise, let’s say there's a random chance to find a key while exploring a cave. Implement: `if (rand 1 to 100) <= 50 then` (50% for demonstration) `set [hasKey] to true` and `say "You found a rusty key on the ground."` in that branch. In the else, maybe `say "No key was found here."` This way, sometimes the hero ends up with hasKey = true.
41. **Using the Key**: Later in the story, there's a locked treasure chest. We only want the hero to open it if hasKey is true. Implement another conditional: `if (hasKey) then ... else ...`. In the true branch: `say "Using the key, you unlock the treasure chest and find gold!"`. In the false branch: `say "The chest is locked. If only you had a key..."`. This creates two different story outcomes depending on the earlier state.
42. **Test Both Scenarios**: Because the key find was random 50%, run the story multiple times. On runs where "You found a rusty key" happened, later you should see the chest unlocking path. On runs where no key was found, you should hit the locked chest message. Notice how the `hasKey` variable carried that information across time – the program remembered whether the hero has the key. If you see any logical flaw (like the chest opening text when you know no key was found), then the state logic might have an error (maybe hasKey was not reset properly or condition check wrong). Debug accordingly.
43. **Maintain State in Loops or Custom Blocks**: If the acquisition or use happens inside a custom block or loop, ensure that `hasKey` is still a global or accessible outside. For example, if you found the key inside a loop that then ends, hasKey (global) would still retain true. Good. But if you had a custom block that had a local variable `foundKey` instead, that wouldn't persist globally – so prefer global for story-critical states or ensure to pass it out.
44. **Complex State**: If feeling confident, try a more complex state situation: for example, track multiple keys or items with a list. Maybe there's also a `inventory` list. When key is found, do `add "rusty key" to [inventory]` instead of just setting a boolean. Then later check `if <list contains "rusty key"?>`. Snap! doesn't have a direct "contains" block for lists, but you can use the `list` reporter combined with some logic or use the `find` block approach: Actually, Snap! might allow you to use the reporter `item # of thing in list` which returns index or 0 if not found (the Scratch 3 has "item # of thing in list"? I'm not certain Snap has exactly that, but Snap being advanced likely has a way to find an item or you can iterate to check). For simplicity, maybe skip contains if not obvious; the boolean approach is fine.
45. **Consistent Narrative**: State tracking also means removing or altering possibilities once things change. For instance, if the hero used the key, maybe set `hasKey = false` after unlocking (the key is used up). Or if an NPC died, have a flag `npcAlive = false` and then ensure no further encounters with that NPC happen. These might not appear in this small exercise, but think about your full story: do you have any one-time events or items? Ensure your code doesn't let them accidentally happen twice. You can use state to guard against repeats (like only add item if not already have it, etc.).

### Quiz (Self-Evaluation)

- **Q1:** What is a state variable, and why is it important in a branching story program? Give an example from a story context.
- **Q2:** How would you check if an item (say "MagicStone") is in the player's inventory list in Snap!? (Hint: Think about using the list blocks or looping through the list items).
- **Q3:** Suppose `hasMap` is a flag that indicates the hero has a map. Write pseudo-code for a scenario where if the hero has the map, they navigate the forest easily (print a success message), otherwise they get lost (print a different outcome).
- **Q4:** Why should you initialize state variables at the start of a program, especially in Snap! when running multiple times? What could go wrong if you don't?

Reflect on these answers to confirm you understand state management.

### Project Component: **Memory of the World** – Strengthening Your Story’s Consistency

Let’s fortify your story’s continuity by systematically managing state:

- **List Out Important States**: Think through your story and jot down things that should be remembered. This could include: items the hero can obtain (we did key example; maybe also weapons, artifacts), important decisions (did the hero side with Character A or B), outcomes of battles (is the villain alive or not), and location-based flags (visited temple, solved puzzle, etc.). These are all candidates for state variables or list entries. It's okay if not all apply; pick a couple that matter in your narrative.
- **Create Variables/Lists for Them**: For each identified state, ensure you have a variable or list tracking it. If you already have some (like `hasKey` from above, or `heroStrength` for numeric state), great. If not, create them now. For boolean ones, decide initial false/true; for counts, initial 0; for lists, start empty or pre-populated as appropriate (inventory empty initially, etc.). Place these initializations at the beginning of your program (often under a "when Green Flag clicked" script). This way, every run resets to a clean starting state.
- **Update State During Events**: Find where in your code these state changes would occur. Insert the appropriate updates. Examples: when hero picks up something, `hasItem = true` or `add item to inventory`. When a decision is made, set a flag like `alliedWithDragons = true`. When a boss is defeated, set `bossDefeated = true`. Make sure these lines execute at the correct time (within the if that detects the event, etc.). Use custom blocks to your advantage: if you have a custom block handling an event that leads to a state change, you can include the state update inside it.
- **Use State in Conditional Storytelling**: Now go to the later parts of the story where those states should have effects. Write conditionals to branch or alter text based on the state. For example: if `alliedWithDragons` is true, maybe the dragon appears as a friend in the final battle, otherwise it's an enemy. If `treasureList` contains "Sapphire", perhaps the ending describes the hero using it. Ensure that for each state variable, there's at least one place later where it influences the narrative. This not only adds coherence but also gives player actions/choices lasting impact.
- **Prevent Contradictions**: Also check if something should _not_ happen because of state. E.g., if `bossDefeated` is true, then you shouldn't run the boss encounter again. You might wrap the boss encounter code in `if (bossDefeated = false) then ...` to ensure it only runs if boss not already defeated. Or remove an item from a list once used, so it can't be used again. Skim through your script for any such potential double occurrences and use state to guard them.
- **Test a Full Playthrough for Each Branch**: This might require forcing some flags for testing. Run your story and try to hit one set of outcomes (maybe by adjusting probabilities to guarantee or by temporarily setting variables for test). See if the story makes sense. Then try the alternate path. For example, test with `hasKey` flow vs not; test with allied vs not allied scenarios. Does each path read coherently, referencing only what it should? If you find, say, the story mentions an item the hero doesn't have or assumes knowledge they shouldn't, then adjust the logic. You might need additional conditionals to adjust text (maybe a different line of dialogue if a character is absent, etc.). It can be a bit of detail work, but it's rewarding to see a logically consistent story.
- **Document in Comments**: It might help to add comments in your code about the role of each state variable, especially if some are interconnected. For example, `villainDefeated` might imply `hasKeyToCastle` (if villain held it), etc. Comments won't affect the program but help you or others understand the dependencies.

By tightening up state management, you've effectively taught your storytelling program to "remember the past" and honor it in the narrative. This transforms a random branching story into a cohesive simulated world where actions have consequences. The computational thinking skill here is **handling complexity**: using abstraction (variables represent complex story conditions in a simple way) and **logic** to maintain consistency. Save your story with these improvements. In the upcoming lessons, we'll likely move to structuring the overall narrative (scenes and chapters) and then final touches. You're doing fantastic – your world now not only generates creatively, but it does so with an internal logic that's believable!

---

## Lesson 9: Scenes and Structure – Organizing the Narrative Flow

### Introduction

Your story world is now rich and complex. To ensure it all comes together, let's discuss the **structure** of your narrative and how to organize your code accordingly. Just as novels have chapters or plays have acts, long programs benefit from being organized into sections or **scenes**. In Snap!, we can manage this by using custom blocks as scene handlers or by using broadcast messages to trigger different parts of the story sequentially. This lesson will focus on how to keep each part of your story modular and how to transition between scenes smoothly. By giving each scene its own “stage” in code, you make it easier to manage the flow (especially if later you want to reorder or reuse a scene). Also, we’ll ensure that each scene checks the relevant state and sets up the next one properly. The goal is a modular design: each lesson’s content (scenes) can stand alone, but when combined, they form a coherent saga. _(A new learner could apply this by imagining a story with 3 scenes and coding each separately, then linking them, to grasp the idea.)_

### Key Concepts

- **Scene Management**: A scene could be a portion of the story with a specific purpose (introduction, conflict, resolution, etc.) or a location-based segment (village scene, forest scene, castle scene). You can implement scenes in Snap! by grouping the blocks for that scene in a custom block or under a broadcast “when I receive [SceneName]” script. The advantage of custom block is it's like a function call (straight line flow), whereas broadcast allows more asynchronous or event-driven flow (Snap! will start that script when broadcast is sent). For linear storytelling, either works, but broadcast can simplify visual separation.
- **Broadcasting Events**: In Snap!, you can `broadcast "scene2"` at the end of scene1 to trigger the script labeled `when I receive "scene2"`. This is an event-driven approach. It’s beneficial if scenes might not always happen in the same order (though in a story usually they do), or if you have multiple scripts that should run concurrently in a scene. If using broadcast, keep in mind that after broadcasting, the current script continues (unless you use `broadcast ... and wait`, which pauses until handlers finish). Usually, one uses `broadcast and wait` in a linear story context to ensure sequential execution.
- **Modularity and Reusability**: Designing scenes as separate blocks or broadcast receivers means you can tweak or even skip them easily. For example, if you wanted to have an alternate path that jumps to scene3 directly, you can choose not to call scene2 block or not to broadcast it. This modular design also aligns with the Kansas Star principle of clarity: each part of the program deals with a specific portion of the story, making the code easier to read and maintain.
- **Flow Control**: Ensure there is a clear flow from one scene to the next. This can be done explicitly by sequence (calling one custom block after another, or broadcasting next scene at end of current). If any scene should be optional or repeatable (like maybe the hero can revisit a place), you'll need logic to handle that (like a loop or a menu system which is beyond our current scope but conceptually, you'd broadcast based on choice). For our purposes, assume mostly linear progression with branching inside scenes.

### Hands-On Exercise: Structuring Scenes with Broadcast

We'll create a simple three-scene structure to illustrate: Scene1 (intro at village), Scene2 (journey/battle), Scene3 (conclusion).

46. **Define Scenes**: Decide on how many scenes and their names. For exercise: "Intro", "Adventure", "Finale". In Snap!, make three scripts:
    - `when green flag clicked` -> this will trigger Scene1. (We could directly start Scene1 on green flag or broadcast "Intro").
    - `when I receive "Intro"` -> put the content of scene1 here. E.g., narrate the setting and a call to adventure. End it with a `broadcast "Adventure" and wait`.
    - `when I receive "Adventure"` -> content of scene2 (maybe the hero travels and fights a monster). At its end, broadcast "Finale" and wait.
    - `when I receive "Finale"` -> content of scene3 (resolve story, e.g., hero returns home victorious). No further broadcast since it's the last scene; maybe end with a `say "The End."`.
47. **Fill Scene Content**: You likely have content from previous lessons that fits into these scenes. For instance, in Intro you might greet the hero, maybe let them choose a name or present initial variables (we did heroName variable etc.). In Adventure, you might include the loops of journey (Lesson4), a random encounter (Lesson7), perhaps using the state flags (Lesson8) to determine outcome. In Finale, use those flags for the ending (like if villainDefeated true, say one ending, else another). For now, focus on structure more than content – you can stub it out like: Intro says "Hero starts at village." Adventure says "Hero travels and faces danger." Finale says "Hero returns safely." just to test the flow.
48. **Trigger the Flow**: Under `when green flag clicked`, add a `broadcast "Intro" and wait`. This ensures when you click start, it goes into the Intro scene. Inside Intro, at end, we broadcast Adventure, etc. The `and wait` is important to keep order (Scene1 fully plays out, then Scene2). Without "and wait", Snap! would trigger scene2 and also continue scene1 script if it had more lines after broadcast. Here we structured each as separate triggers, so not using "and wait" could even allow them to overlap. For linear, always do `and wait` unless you intentionally want parallel scenes (unlikely in narrative).
49. **Test Transition**: Run the project. You should see the Intro text, then automatically the Adventure text, then Finale text, in order. If something doesn't show up, check that broadcasts match exactly (case-sensitive strings). The advantage of this approach is you clearly see in code the sections. If all good, integrate actual story content: copy or move the relevant code blocks into these `when I receive` scripts. For example, all your introduction narration and variable setups go into "Intro" script. The loop of days and encounters go into "Adventure". The final outcome bits go into "Finale". You may need to tweak because earlier you might have had it all one long script; breaking it means e.g., variables set in Intro should still be available in Adventure (they will, if global). Ensure any local script vars from before are changed to global or passed along if needed. Usually simpler: just use global for anything that spans scenes.
50. **Alternate Method (Custom Blocks)**: If you prefer custom blocks, you could instead do: in green flag script, call `Intro` (custom block), then immediately call `Adventure`, then `Finale`. That works too, and might even be simpler logically. The broadcast method is useful if you plan to have other things listening or want to easily jump around. Both achieve modular structure. If you try custom blocks: create `Intro` block (no inputs), define it with intro content, similarly `Adventure`, `Finale`. Then do `when green flag: Intro; Adventure; Finale;`. The content inside those blocks executes sequentially. There's no inherent difference in output, just another style. Use whichever you find clearer. (Broadcast is more Scratch-like event approach; blocks are more traditional function call approach).
51. **Flexibility of Structure**: Now appreciate the benefit: say you wanted to skip Adventure (maybe for a quickplay mode), you could just not broadcast it or call it. Or if you want to run Adventure twice (maybe a loop of multiple quests), you could call it twice or loop the broadcast. Also, locating code is easier: want to edit the ending? Just open Finale script. This separation also implicitly follows our lesson modular approach: each lesson's content fell into roughly one "scene". This makes each part understandable on its own (someone could read just the Adventure script and see that part of story logic isolated).

### Quiz (Self-Evaluation)

- **Q1:** What are the benefits of dividing a story program into distinct scenes or sections? Name two.
- **Q2:** How does `broadcast "SceneName" and wait` differ from `broadcast "SceneName"` in Snap!, and why is that important for story flow?
- **Q3:** If you wanted to allow the story to have two different second acts (say, "AdventureInForest" vs "AdventureAtSea") based on a choice, how might you structure your broadcasts or calls? (Hint: perhaps broadcast one of two messages depending on a variable or user's choice, both leading to the finale eventually.)
- **Q4:** In your opinion, which approach do you find clearer: organizing scenes with broadcast events, or using custom block calls for each scene? Why? (This is subjective—think which makes it easier for you to follow the code.)

Thinking about these will ensure you understand scene-based organization.

### Project Component: **Chapter by Chapter** – Implementing a Clear Structure in Your Story

Now let's apply a solid structure to your generative story:

- **Outline Your Story**: Identify the major sections of your narrative. You might already implicitly have them. Commonly: Introduction/Setup, Middle/Conflict, Ending/Resolution. Or you might break it by location or quest phases. Aim for 3-5 sections (matching our 12-lesson modules might be too granular; better to group multiple lessons into one scene where it makes sense). For instance, Lessons 1-3 content was intro (setting and characters), lessons 4-8 could be the journey and challenges (middle), and lessons 9-12 wrap up (end). But use whatever fits your actual story flow. Write down these scene labels.
- **Create Scene Handlers**: Implement using either broadcast or custom blocks. For clarity, let's do broadcast since we demonstrated that. For each scene, make a `when I receive "[SceneName]"` script. If one is the start, you can trigger it from green flag or just use "when green flag" as scene1 directly. Alternatively, always start with green flag broadcasting "Scene1". E.g., `when green flag -> broadcast "Scene1" and wait`. Then scene1 script at its end does `broadcast "Scene2" and wait`, and so on. Set these up empty first as a skeleton, to ensure the chain works.
- **Partition Your Code**: Now take the code you have and move it into the appropriate scene scripts. This might be straightforward if you had already somewhat ordered it. If your code is currently one big when flag script, you'll cut it at logical points. Example: all the intro narration and initial choices goes into Scene1 script. Find where that intro ends (maybe when the journey begins), cut there. The next part (travel and encounters) goes to Scene2. The final confrontation or return goes to Scene3. You might need to add broadcasts accordingly. If you've used custom blocks per lesson, you can simply call those inside the scene scripts or integrate them. E.g., Scene2 might call the `encounterCreature` block multiple times or loop etc., which is fine. The main thing is ensuring variables set in earlier scenes persist to later (which they do as global) and that each scene ends by triggering the next.
- **Check Scene Transitions**: After splitting, run through the story. Does it progress from Scene1 to 2 to 3 properly? If it stops early, perhaps a broadcast was not called or you forgot an `and wait` causing sequence issues. Fix as needed. The output should be the same story as before structurally, just now the code is segmented. Ideally, the player/reader shouldn't notice any difference (besides any new text you might have added for smooth transition).
- **Modular Testing**: One cool thing now: you can test scenes in isolation by triggering their broadcasts manually (like clicking the yellow "broadcast Scene2" block in the palette or using the green flag to jump into scene2 if you modify it for testing). This can help debug a particular section without running the whole story. For now, do a full run to ensure integration: the state from scene1 (variables like hasKey or heroName) should be correctly used in scene2, etc. If something isn't carried over, likely a scope issue (maybe you accidentally re-declared a local variable in a block hiding the global). Resolve by using global consistently.
- **Optional: Scene Skipping Logic**: If there's a part of your story that might not occur depending on earlier choices, you can incorporate that now easily. For example, if you had an alternate path skipping a scene, you could do something like: in Scene1, if choice A then broadcast "Scene2A", else broadcast "Scene2B". And have two different receivers for those. Both could eventually broadcast "Scene3". This is optional and adds complexity, but mention it for completeness. It shows how the broadcast structure allows branching at a scene level, not just within scenes. Ensure such branching is consistent (you don't want to accidentally trigger both scene2s). This essentially becomes a little state machine of scenes. Only attempt if you feel your story would benefit and you can handle the logic. If not, keep it linear.
- **Documentation**: Add a comment at the top of each scene script summarizing what that scene covers (e.g., "Scene2: The hero travels through the forest and fights a monster"). This will help anyone (or you in the future) reading the code understand the story flow at a glance. It's akin to chapter titles.

Now your story program is organized like a book, with clear chapters. This makes it easier to add to or modify each part without breaking others. You've essentially followed the principle of **modularity** to the highest level of your program's design. The narrative journey from start to finish is now laid out logically in the code. Great job! Save your project with maybe a suffix like "_Structured" to differentiate from earlier versions. Next, we will likely discuss final touches, polishing, and bringing everything together for the grand finale.

---

## Lesson 10: Interactive Tales – Adding User Input and Choices

### Introduction

Stories are even more engaging when the audience can participate. In this final lesson, we'll focus on **interactivity** – letting the user make choices or provide input that affects the story. You've already crafted a rich world with computational logic; now you can invite the reader/player to co-author in small ways. In Snap!, the simplest way to get input is using the `ask ... and wait` block, which lets the user type an answer (which we can store in the `answer` variable). We can ask for the hero's name, ask trivia or riddles, or present choices for directions ("left or right?"). Another form of interactivity is choosing between options, which could be done by `ask` (with the user typing "left" or "right") or by using keys or clicking, but since we're text-focused, we'll stick to ask/answer method. We'll incorporate at least one meaningful user choice into your story – maybe at a branch that was previously random or predetermined, now the user can decide. This not only makes the experience more immersive, but also showcases the full spectrum of computational thinking: your program must handle unpredictable input robustly and still maintain story coherence.

_(For new learners, this lesson can be done by making a tiny scenario that asks a question and branches accordingly, to see how Snap! input works. For the full project folks, integrate input into the existing structure.)_

### Key Concepts

- **Ask and Answer**: The `ask "question" and wait` block pops up a dialog (or in some Snap! environments, a prompt at bottom) for the user to type a response. The response is then stored in the built-in variable `answer`. You should usually capture this into your own variable if you'll use it later (since `answer` might change if you ask again). For instance, `ask "What is your name?" and wait`, then do `set [heroName] to answer`. Note: The `answer` stays as last answer until overwritten by another ask.
- **Input Handling**: User input is free-form text (always a string). If you expect a number, you'll get a string of digits which you may need to convert (Snap! might auto-convert numeric strings to numbers in numeric contexts though). If expecting specific answers (like "yes" or "no"), consider that users might type variations or add spaces. You may want to sanitize input: e.g., use `answer` in lower case via an operator or check substrings. Snap! is not case-sensitive for text comparison I think? Actually, Scratch isn't, Snap likely is case-sensitive by default since it's more formal. Safer: convert answer to lower-case (Snap has a block for that in Operators, I recall something like `((answer) to lower case)` or similar). Then compare to "yes"/"no". Or instruct user clearly (like "Type yes or no").
- **Branched Choices**: For a multiple-choice like "left or right?", an if/else on `answer` works: `if <answer = "left"> ... else if <answer = "right"> ... else (some default if they typed something unexpected)`. It's good to handle unexpected input gracefully, maybe by re-asking or defaulting. But for simplicity, we might assume the user follows instructions, or we could implement a simple loop: repeat ask until answer is one of the expected options. That would improve robustness. (This gets into user input validation, a good practice in programming but can be advanced if doing many options).
- **Impact on Story**: Decide where the user input matters. It could be cosmetic (their name for personalization), or a story branch (choice of path or action), or even a skill test (maybe ask a riddle and only proceed if correct?). In a generative story, user choices combined with randomness and logic create a truly unique experience each run. But be mindful of scope: adding input means another dimension of variation, so ensure your code accounts for all possible answers that you care about.

### Hands-On Exercise: Adding a Choice

Let's implement a simple choice: at a crossroads, ask the user "left or right?" and branch the story accordingly.

52. **Ask the Question**: At the appropriate spot in your story (maybe in the Scene2 adventure, after some lead-up), insert `ask "At a crossroads, do you go left or right?" and wait`. This will pause the story for input.
53. **Capture Answer**: Snap! automatically places it in `answer`. Immediately after, do something like: `set [direction] to (answer)` (make a variable `direction`). And/or you can directly use `answer` in conditions, but storing in a variable is good if you'll check it multiple times or want to convert case. Optionally, convert to lower-case for safety: Snap might have a block `to lower case ( )` - I'm not entirely sure if Snap has that built-in (I know Snap has a lot of list and text processing capabilities). If it does, use `set [direction] to (to lower case (direction))`. If not, it's okay; just be aware "Left" vs "left" might not match exactly in condition. For testing, just type lowercase.
54. **Branch Based on Answer**: Use an if/else (or if/else if chain if more than 2 options). Example:
    
    ```scheme
    if <direction = "left"> 
        say "You venture left, into the shadowy forest." for 2
        broadcast "ForestScene" and wait  // maybe leads to a forest encounter
    else 
        say "You turn right, towards the sunny meadow." for 2
        broadcast "MeadowScene" and wait  // leads to a different scene or outcome
    ```
    
    If you are doing just within one scene, you could instead do the consequences right there instead of broadcasting new scenes. But using separate scenes for each path might be cleaner if they diverge a lot. Or if it's just a minor difference and then converges, you can handle it with if logic then converge back. Up to you. For demonstration, let's say two distinct mini-scenes. So you'd also create `when I receive "ForestScene"` and `when I receive "MeadowScene"` scripts to continue each storyline. Eventually, those might converge back to the main Finale (maybe both broadcast "Finale" at end). This approach essentially allowed a mid-story fork chosen by user.  
    If you don't want to complicate with new scenes, an alternative:
    
    ```scheme
    if <direction = "left">
        // narrative for left path
    else if <direction = "right">
        // narrative for right path
    else 
        say "Confused, the hero stands still." // if unexpected input
    ```
    
    And then continue on a single storyline (assuming both left and right lead to same next steps). This might break immersion a bit if they type wrong, but it's a simple fallback. If you want, you can loop ask until they give a valid answer:
    
    ```scheme
    repeat until <direction = "left" or direction = "right">
        say "Please type 'left' or 'right'." for 2
        ask "Left or right?" and wait
        set [direction] to answer
    end
    // then proceed with if direction = left etc.
    ```
    
    This ensures the story doesn't proceed until a valid input is given. But be careful to avoid infinite loop if something unexpected (like user closes program); Snap will just keep asking though. It's fine for our purpose.
55. **Test the Choice**: Run the story and when prompted, try typing "left". See that you get the left path narrative. Run again, type "right". Ensure it goes the right path. Try an incorrect input like "forward" and see how your code handles it (if you did an else with a default, you'll see that). Adjust messaging if needed ("Please answer left or right.").
56. **Name Input (Optional)**: Another common use of ask is at the very beginning to ask the user's name. You can do `ask "What is your name?" and wait`, then set `heroName = answer`. Then use `heroName` variable in story text (like greet them). We already had a variable for heroName we set manually; this is a nice enhancement to personalize. Just be sure to use join blocks to include the name in sentences ("Welcome, [heroName]!"). If you implement this, test with some name, see it appear. It's a simple but magical experience for users to see their input reflected.
57. **Other Creative Inputs**: If you have time, you could replace a random event with a user choice. Perhaps earlier we had a random chance to find an item; you could instead ask "Search the area? (yes/no)" and if yes then do a random or guaranteed find, if no skip. Or ask a riddle: if they answer correctly you set a flag to allow them to pass, else something else happens. These interactive elements give a slight "game" feel. But careful: too many questions can slow the narrative, so find a balance. One or two meaningful choices might suffice.

### Quiz (Self-Evaluation)

- **Q1:** How does the `ask ... and wait` block work, and where is the user's input stored?
- **Q2:** Why is it important to consider different ways a user might respond (e.g., uppercase vs lowercase, synonyms) when writing conditions for user input? How could you handle that?
- **Q3:** Write an example of a Snap! code snippet that asks the user for a direction (north, south, east, or west) and then uses an if/else if structure to handle each case with a different print-out. Include a default case for an invalid direction.
- **Q4:** What could you do if you wanted the user to be able to input a number (say a guess) and compare it to a secret number? What blocks or conversions might be needed? (Think about answer being text vs number.)

Answering these will check your understanding of handling input.

### Project Component: **Your Choice, Your Story** – Integrating User Interaction

Bring your story alive by adding the user's touch:

- **Decide on Input Points**: Review your story and identify at least one place where a user choice or input would be fun and meaningful. Good spots: character creation (name or choose an attribute), a pivotal decision (which quest to pursue, how to approach a problem), or answering a challenge (solve a puzzle, decide a strategy). If your story had a branching path that was randomly decided or pre-coded, that could be a candidate to turn into a player choice. Also consider adding the name prompt at the start if not already there, to personalize the adventure.
- **Implement the Ask**: Insert the `ask ... and wait` block with a clear prompt. Ensure the prompt tells the user how to answer (if it's a choice, list the choices; if a free question, make it clear what you expect). Immediately capture `answer` into a variable if you'll refer to it multiple times or in different places. For a quick single check, you can use `answer` directly in an if, but usually storing is safer.
- **Add Logic for Responses**: Based on the input, use if/else to direct the story. This might create a new branch in your code. If it's at a scene level like earlier, you might broadcast different next scenes. If it's local, just do different narrative then converge. Make sure to handle at least the expected answers. If feasible, handle unexpected input: either by reprompting (loop until valid) or by defaulting ("I'll take that as a 'no'"). Error handling improves user experience, but if time is short, at least provide a default outcome on invalid input so the story can continue. Document in a comment that it's a user choice section for clarity.
- **Integrate with State**: If the choice should affect future logic, store the result in a state variable. Example: if they choose the Forest path, set `pathChosen = "forest"`. Later, in the finale, you might have a different ending or ally depending on that. Or a simpler one: if they choose to help a character vs ignore them, store that decision in a flag `helpedCharacter = true/false` and use it in later scene to influence outcome (maybe that character comes to help in final battle if helped earlier). This ties user input into the state system you've built, making it a persistent consequence.
- **Test Interactively**: Run your story in the Snap! player and actually play through it. Does the prompt appear and wait for you? If you don't answer, the story should pause (that's normal). After answering, does it proceed correctly down the branch you chose? Test each branch by running again and giving different answers. If any branch isn't working or ends abruptly, debug the logic. Ensure that after branching, the story still converges or continues properly to the end. For example, if you created two separate scene scripts for left/right, they both should eventually lead to the same finale or their own appropriate endings. Don't leave one branch hanging. Possibly you need to duplicate some end sequence in both, or better, have them broadcast a common "Finale" scene to join back. Try a full playthrough for each choice path to see the complete narrative.
- **Polish**: Minor things add polish, like echoing the user's input in the narrative. E.g., after asking name, `say (join "Welcome, " heroName)` so they see their name in text. Or if they chose left, maybe later refer to "Because you went left, you found X". This makes choices feel impactful. Also, if you loop asking for correct input, make sure the prompts aren't annoying and it breaks out properly. And reinitialize `answer` usage if you have multiple asks (Snap!’s `answer` updates each time, but if you store to separate variables you're fine).
- **Final Save**: Save your project one last time. You now have a full-fledged interactive generative story! It's modular, logical, and engaging.

Your curriculum journey is complete, and your world is ready to explore. The final program is a testament to how computational thinking and creativity come together. You've maintained clear structure (Kansas clear and concise writing in code as well as text), modular design (each lesson/scene stands alone but also forms part of a larger journey), and compelling content. Time to share your story and maybe watch others experience the myriad of possibilities it offers!

Congratulations on building a generative, interactive story from the ground up. By revising and enhancing each component systematically, you've not only created an exciting narrative but also learned valuable programming and problem-solving skills. This combination of world-building joy and computational thinking is what generative storytelling is all about. Happy storytelling and coding!